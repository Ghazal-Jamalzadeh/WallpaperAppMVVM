توی اپیزودهای پیجینگ خیلی کامل توضیح داده شده سازوکار استفاده از کتابخانه
حالا اینجا مختصر تر توضیحح داده میشه

Paging source---------------------------------------------------------------------------------------
1-
اول نیاز به یک کلاس پیجینگ سورس داریم
ورودی این کلاس دو تا دیتا تایپ میگیره داخل <>
اولیش رو int میدیم که مال اون عدد شماره پیج ماست
دومیش دیتاتایپ لیست ماست
هر پارامتر دیگه ای هم نیاز داره جزو پارامترهای کانستراکتور میدیم بهش

2-
دو تا مند اورراید میکنه که اولی رو کاری باش نداشتیم و نال رو ریترن میکنیم
دومی اون متدیه که توش کد میزنیم

3-
یک متغیر تعریف میکنیم که ایندکس ها رو میریزیم توش

4-
    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, ResponsePhotos.ResponsePhotosItem> {

    توی این متغیر میایم شماره صفحه جاری رو از پارمز میگیریم و اگه چیزی نداشت خودمون یک رو میدیم بهش
        val position = params.key ?: pageIndex

        ریترن تایپ این متد حتما باید داهخل ترای کش باشه که خودمون هندل کنیم اکسپشن ها رو
        این الزام کتابخانه هست
        return try {

            فراخوانی سرویس
            val response = api.getCategoryPhotos(id, position)

            توی فصل یک این ریسالت رو اد آل میکردیم به یک لیست دیگه
            اینجا مستقیم استفاده ش میکنیم
            حالا باید دید فرقش چیه
            احتمالا صرفا برای هندل کردن نال بوده
            توی فصل یک این خط کد بهتر هندل شده بود
            val data = response.body()!!

            در نهایت استیت پیج رو امیت میکنیم
            و پارامتر دیتا رو میدیم بهش
            شماره صفحه بعدی و قبلی رو میدیم بهش
            اکه شماره صفحه صفر شه باید نال کنیم
            LoadResult.Page(
                data = data,
                prevKey = if (position == pageIndex) null else position - 1,
                nextKey = if (data.isEmpty()) null else position + 1
            )

        } catch (e: Exception) {
        اگه افتاد توی کش استیت ارور رو توی لود ریسالت امیت میکنیم
            LoadResult.Error(e)
        }
    }