توی اپیزودهای پیجینگ خیلی کامل توضیح داده شده سازوکار استفاده از کتابخانه
حالا اینجا مختصر تر توضیحح داده میشه

Paging source---------------------------------------------------------------------------------------
1-
اول نیاز به یک کلاس پیجینگ سورس داریم
ورودی این کلاس دو تا دیتا تایپ میگیره داخل <>
اولیش رو int میدیم که مال اون عدد شماره پیج ماست
دومیش دیتاتایپ لیست ماست
هر پارامتر دیگه ای هم نیاز داره جزو پارامترهای کانستراکتور میدیم بهش

2-
دو تا مند اورراید میکنه که اولی رو کاری باش نداشتیم و نال رو ریترن میکنیم
دومی اون متدیه که توش کد میزنیم

3-
یک متغیر تعریف میکنیم که ایندکس ها رو میریزیم توش

4-
    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, ResponsePhotos.ResponsePhotosItem> {

    توی این متغیر میایم شماره صفحه جاری رو از پارمز میگیریم و اگه چیزی نداشت خودمون یک رو میدیم بهش
        val position = params.key ?: pageIndex

        ریترن تایپ این متد حتما باید داهخل ترای کش باشه که خودمون هندل کنیم اکسپشن ها رو
        این الزام کتابخانه هست
        return try {

            فراخوانی سرویس
            val response = api.getCategoryPhotos(id, position)

            توی فصل یک این ریسالت رو اد آل میکردیم به یک لیست دیگه
            اینجا مستقیم استفاده ش میکنیم
            حالا باید دید فرقش چیه
            احتمالا صرفا برای هندل کردن نال بوده
            توی فصل یک این خط کد بهتر هندل شده بود
            val data = response.body()!!

            در نهایت استیت پیج رو امیت میکنیم
            و پارامتر دیتا رو میدیم بهش
            شماره صفحه بعدی و قبلی رو میدیم بهش
            اکه شماره صفحه صفر شه باید نال کنیم
            LoadResult.Page(
                data = data,
                prevKey = if (position == pageIndex) null else position - 1,
                nextKey = if (data.isEmpty()) null else position + 1
            )

        } catch (e: Exception) {
        اگه افتاد توی کش استیت ارور رو توی لود ریسالت امیت میکنیم
            LoadResult.Error(e)
        }
    }

Repository------------------------------------------------------------------------------------------
کد مربوط به این قسمت توی فصل یک داخل ویومدل نوشته شده بود و فرق داشت از نظر آپشن ها
و به صورت فلو استفاده میکردیم
اینجا به لایو دیتا تبدیل میکنیم
ولی کانفیگی که اینجا نوشتیم کانفیگ کامل تری هست
    fun categoryPhotos(id: String) = Pager(
        config = PagingConfig(pageSize = 20, maxSize = 100, enablePlaceholders = false),
        pagingSourceFactory = { CategoriesPagingSource(api, id) }
    ).liveData

ViewModel-------------------------------------------------------------------------------------------
توی فصل یک توی ویومدل کانفیگ پیجینگ رو تعریف میکردیم
که اینجا همونطور که گفتیم بردیمش توی ریپازیتوری اون بخش رو

توی مثال فصل یک ما فقط شماره پیج رو به سرویس میفرستادیم
ولی اینجا یک آیدی هم میخوایم بفرستیم که یکم متفاوت تر و پیچیده ترش میکنه
شاید در نگاه اول بگین خب چه فرقی داره یک فانکشن تعریف میکنیم و یک ورودی بهش میدیم دیگه
ولی به صورت عادی این طوری نیست
چرا این طوری نیست؟
برای اینکه اگر با وضعیتی که اینجا میریم جلو
یعنی با استیت ( که جلوتر میفهمیم چیه)
(البته روش های مختلفی وجود داره و این یکی از بهترین روش هاست.
 خود گوگل هم خیلی روی این روش تاکید داره و میگه با این روش برین جلو
 ولی مستندات کاملی نداره اصلا
  پس این آموزش رو خیلی جدی بگیرید
  چون اگر پیجینگی دارید که قراره دیتای اضافه ای بگیره
  صد در صد جلوتر به مشکل خواهید خورد )

زمانی که ما از استیت استفاده نکنیم و به صورت خیلی عادی و بیسیک بریم جلو چه اتفاقی می افته؟
اگه خیلی عادی ورودیا رو بفرستی چی میشه؟
زمانی که توی فرگمنت استفاده میکنی میبینی که ورودی رو نمیگیره
و بدون اون ورودی میخواد عملیات رو برات انجام بده

برای هندل کردن این موضوع از استیت خود ویومدل استفاده میکنیم
و دیگه خیالمون راحته که اطلاعات درست رو دریافت میکنیم

@HiltViewModel
class CategoriesViewModel @Inject constructor(private val repository: CategoriesRepository, state: SavedStateHandle) : ViewModel() {


برای این موضوع از یک لایو دیتا استفاده میکنیم که داخل استیت خود ویومدل هست
این لایو دیتا از ما دو تا ورودی میگیره
اولیش کویری هست
که البته منظور از این کوءری اون کوءری نیست که تو دیتابیس و این هاست
مثلا دسته بندی چی باشه و این ها

دو تا ورودی ما یکیش کارنت کوعری هست
یعنی چیزی که الان هست
و یه دونه هم حالت پیش فرض
چرا؟
چون به واسطه این حالت پیش فرض بهش میگه حتی اگه هیچ ورودی برای تو در نظر نگرفت
تو همه رو بده

دسترسی به این لایو دیتای خاص از طریق استیت خود ویومدل هست
و خب ما به جای اینیشیالایز کردن چیزایی که نیاز داریم داخل کلاس به کلاس تزریقشون میکنیم

ما این متغیر رو پرایویت تعریف میکنیم
چون فقط اون حالت پیش فرضمون رو میخوایم بهش بدیم
شاید بپرسید پس ورودی رو کجا ست میکنی؟
اون رو به یک شکل دیگه قراره ست کنیم
این فقط داره اون حالت پیش فرض  و حالت کنونی رو برامون برمیگردونه
که فقط میخوام توی این صفحه دسترسی داشته باشم
حالت پیش فرض که مشخصه. استرینگ خالی است
هر دوی این کوعری ها به صورت ثابت هستن
    private val currentData = state.getLiveData(CURRENT_QUERY, DEFAULT_QUERY)

 ***************** نکته خیلی مهم و جالب *********
 میتونی کانستنت ها رو بیاری توی همون فایل همیشگی کانستنت تعریف کنی
 ولی اگه کانستنتی داره که دوس داری فقط توی همون کلاس بهش دسترسی داشته باشی
 میتونی ببریش توی کامپنین آبجکت تعریفش کنی
 کاربردهای دیگه ای هم داره کامپنین آبجکت
 ولی یه کاربردش همین کانستنت تعریف کردن داخل یک کلاس هست
 *************************************************

 حالا روی اون لایودیتای استیت یک سوییچ مپ میزنیم
 این دیتایی که این بمون میده در واقع همون اطلاعاتیه که برامون برمیگردونه
 مثلا آیدی کتگوری
 از اینجا ریپازیتوری رو کال میکنیم و آیدی رو بهش میدیم
 تا اینجا تمومه
 ولی اگر بخوایم این api کش بشه
 خیلی راحت از حالت کشد این استفاده میکنیم
 و اسکوپ ویومدل رو بهش میدیم
 اینجوری سرویس کش میشه
 اگه چیز جدید داشته باشه میاره
 اگه نه از کش برات میاره
 ولی آپشنال هست و آپشن جالبیه

     val categoriesPhotos = currentData.switchMap { id ->
         // in faghat too code ghabli bood
         repository.categoryPhotos(id).cachedIn(viewModelScope)
     }

 حالا برای آپدیت کردن کوعری باید چیکار کنیم؟
 ورودی رو باید کجا بدیم بهش
 از طریق این متد ست میکنیم
 {
 اگه چندین وروردی داشتیم باید چندین لایو دیتا و چندین سوییچ مپ تعریف کنیم احتمالا
 }
     fun updateCategoryId(id: String) {
         currentData.value = id
     }

Fragment (call api)---------------------------------------------------------------------------------
*************** نکته خیلی مهم درباره لایف سایکل****************
اگه من کدی دارم که میخوام یک بار اجرا شه مثلا کال کردن یک سرویس
یک راهش اینه که ببرم توی بلاک اینیت ویو مدل بنویسم
ولی اگه مثلا دیتایی داره که قراره از آرگز بگیرم چی
خب بازم میشه توی ویومدل هندلش کرد
ولی اگه بخوام توی خود فرگمنت باشه چی؟
اگه توی onViewCreated بنویسم با هر دفعه رفت و برگشت کال میشه
ولی توی onCreate فقط یک بار صدا زده میشه
لایف سایکل ها رو جدی بگیرید
***************************************************************

برای فراخوانی api کافیه متد زیر فراخوانی شه
            viewModel.updateCategoryId(it.topicId)
این صفحه زمانی دیستروی میشه که کلا بک بزنیم ازش و بیایم بیرون
اگه روش صفحه باز کنیم و اون صفحه ها رو ببندیم مجدد فراخوانی نمیکنه سرویس رو

Adapter---------------------------------------------------------------------------------------------
همونطور که توی فصل یک داشتیم
برای آداپتر پیجینگ دیگه از ریسایکلر ویو آداپتر استفاده نمیکنیم
بلکه از پیجینگ آداپتر استفاده میکنیم
که خود این پیجینگ آداپتر از ریسایکلر ویو آداپتر استفاده میکنه
این میتونه ریترای و رفرش و این ها رو که لازم داریم هندل کنه برامون

پارامتر اول دیتا تایپ یک آیتم لیست و پارامتر دوم ویوهلدر رو از ما میگیره


//جلوگیری از روی هم افتادن دیتای آداپتر موقع اسکرول--------------------------------
احتمالا وقتی پیجینگ میکنیم مکنه دیتا هامون بیفته رو هم
راه های مختلفی برای هندل کردن این قضیه وجود داره

1-
یک سری از اطلاعات رو توی مدلمون درست کنیم برای هش
و ایکوالز برامون ست بکنه
{ با دیف یوتیلز هندل کنیم بعنی فکر کنم}
میری توی مدل alt + insert میزنی
حالت equal & hash رو فعال میکنی


2-
آداپتر رو به صورت تزریق پابستگی انجام ندیم
و مستقیم ازش شی بسازیم
{اون وقت میتونیم اینترفیس هم بدیم توی ورودیش :,,,,) }
میتونیم lazy lateinit یا هر چی خواستیم هم تعریفش کنیم
چون یه علت روی هم افتادن دیتای اداپتر همین تزریق وابستگی هست

3-
برای ریسایکلرویوهای سنگین توصیه نمیشه
چون حالت ریسایکلبل رو غیرفعال میکنه
ولی اینجا چون پیجینگ داریم اوکیه
و لایه سنگین نیست
سنگین یعنی مثلا پلی کردن ویدیو سنگین یا ایف و الس های زیاد
 holder.setIsRecyclable(false)

Fragment (set adapter)------------------------------------------------------------------------------
توی آداپترهای معمولی میومدیم از حالت دست دیتا استفاده میکردیم
توی این آداپتر خاص ولی به این شکل مینوسیم برای ست کردن دیتا داخل اداپتر
ورودی اول لایف سایکل
ورودی دوم اطلاعات
    private fun loadData() {
        viewModel.categoriesPhotos.observe(viewLifecycleOwner) {
            categoriesAdapter.submitData(lifecycle, it)
        }
    }

Fragment (init recycler)----------------------------------------------------------------------------
از اون اکستنشن فانکشنی که قبلا نوشتیم نمیتونیم استفاده کنیم توی اینجا
چون آداپتری که داریم خاص هست و مخصوص پیجینگ هست

قبلا میومدیم آداپتر رو به این شکل روی ریسایکلر ویو ست میکردیم
adapter = categoriesAdapter

الان هم میتونیم همین کارو کنیم
ولی میخوایم اون آداپتر ارور و لودینگ پیجینگ رو هم روش ست کنیم
پس یکم متفاوت میشه

withLoadStateFooter
withLoadStateHeader -> masalan baraye application haye chat
withLoadStateHeaderAndFooter -> mishe hata ba zaher haye mokhtalef tarif kard barash

ورودیش هم یک آداپتریه که از loadStateAdapter ارث بری کرده
توی این آداپتر اون لودینگه و ارور و این ها هندل میشه
همون طور که توی فصل یک گفتیم یک دونه از این آداپتر برای کل پیجینگ های پروژه کافی هست

adapter = categoriesAdapter.withLoadStateFooter(LoadMoreAdapter { categoriesAdapter.retry() })

آداپتری که از پیجینگ ارث بری میکنه دو تا متد داره
refresh -> az aval load mikone
retry -> az page current load mikone dobare

Handle states in fragment---------------------------------------------------------------------------
کلا این آداپتر پیج اینیشن قابلیت های خیلی زیاد و باحالی رو بهمون میده
یکی دیگه از این قابلیت های باحال همین متد addLoadStateListener هست
تو حالت عادی هندل کردن این حالت ها چالش های زیادی داره

    private fun loadDataStates() {
        categoriesAdapter.addLoadStateListener { state ->
            binding.apply {
                loading.isVisible = state.source.refresh is LoadState.Loading
                categoriesList.isVisible = state.source.refresh is LoadState.NotLoading
            }
        }
    }

توی فرگمنت سرچ این حالت کامل تر هندل شده و وضعیت امپتی رو هم هندل کردیم
چندین شرط باید چک شه برای این حالت

1- state.source.refresh is LoadState.NotLoading
در حالت لودینگ نباشه اداپتر

2- state.append.endOfPaginationReached
پیجینگ به انتها رسیده و چیزی برای اضافه کردن نداره

3- searchAdapter.itemCount < 1
تعداد آیتم ها از یک کمتر بود یعنی صفر

    private fun loadDataStates() {
        searchAdapter.addLoadStateListener { state ->
            binding.apply {
                loading.isVisible = state.source.refresh is LoadState.Loading
                searchList.isVisible = state.source.refresh is LoadState.NotLoading
                //Empty
                if (state.source.refresh is LoadState.NotLoading &&
                    state.append.endOfPaginationReached && searchAdapter.itemCount < 1
                ) {
                    emptyLay.isVisible = true
                    searchList.isVisible = false
                } else {
                    emptyLay.isVisible = false
                    searchList.isVisible = true
                }
            }
        }
    }
