توی اپیزودهای پیجینگ خیلی کامل توضیح داده شده سازوکار استفاده از کتابخانه
حالا اینجا مختصر تر توضیحح داده میشه

Paging source---------------------------------------------------------------------------------------
1-
اول نیاز به یک کلاس پیجینگ سورس داریم
ورودی این کلاس دو تا دیتا تایپ میگیره داخل <>
اولیش رو int میدیم که مال اون عدد شماره پیج ماست
دومیش دیتاتایپ لیست ماست
هر پارامتر دیگه ای هم نیاز داره جزو پارامترهای کانستراکتور میدیم بهش

2-
دو تا مند اورراید میکنه که اولی رو کاری باش نداشتیم و نال رو ریترن میکنیم
دومی اون متدیه که توش کد میزنیم

3-
یک متغیر تعریف میکنیم که ایندکس ها رو میریزیم توش

4-
    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, ResponsePhotos.ResponsePhotosItem> {

    توی این متغیر میایم شماره صفحه جاری رو از پارمز میگیریم و اگه چیزی نداشت خودمون یک رو میدیم بهش
        val position = params.key ?: pageIndex

        ریترن تایپ این متد حتما باید داهخل ترای کش باشه که خودمون هندل کنیم اکسپشن ها رو
        این الزام کتابخانه هست
        return try {

            فراخوانی سرویس
            val response = api.getCategoryPhotos(id, position)

            توی فصل یک این ریسالت رو اد آل میکردیم به یک لیست دیگه
            اینجا مستقیم استفاده ش میکنیم
            حالا باید دید فرقش چیه
            احتمالا صرفا برای هندل کردن نال بوده
            توی فصل یک این خط کد بهتر هندل شده بود
            val data = response.body()!!

            در نهایت استیت پیج رو امیت میکنیم
            و پارامتر دیتا رو میدیم بهش
            شماره صفحه بعدی و قبلی رو میدیم بهش
            اکه شماره صفحه صفر شه باید نال کنیم
            LoadResult.Page(
                data = data,
                prevKey = if (position == pageIndex) null else position - 1,
                nextKey = if (data.isEmpty()) null else position + 1
            )

        } catch (e: Exception) {
        اگه افتاد توی کش استیت ارور رو توی لود ریسالت امیت میکنیم
            LoadResult.Error(e)
        }
    }

Repository------------------------------------------------------------------------------------------
کد مربوط به این قسمت توی فصل یک داخل ویومدل نوشته شده بود و فرق داشت از نظر آپشن ها
و به صورت فلو استفاده میکردیم
اینجا به لایو دیتا تبدیل میکنیم
ولی کانفیگی که اینجا نوشتیم کانفیگ کامل تری هست
    fun categoryPhotos(id: String) = Pager(
        config = PagingConfig(pageSize = 20, maxSize = 100, enablePlaceholders = false),
        pagingSourceFactory = { CategoriesPagingSource(api, id) }
    ).liveData

ViewModel-------------------------------------------------------------------------------------------
توی فصل یک توی ویومدل کانفیگ پیجینگ رو تعریف میکردیم
که اینجا همونطور که گفتیم بردیمش توی ریپازیتوری اون بخش رو

توی مثال فصل یک ما فقط شماره پیج رو به سرویس میفرستادیم
ولی اینجا یک آیدی هم میخوایم بفرستیم که یکم متفاوت تر و پیچیده ترش میکنه
شاید در نگاه اول بگین خب چه فرقی داره یک فانکشن تعریف میکنیم و یک ورودی بهش میدیم دیگه
ولی به صورت عادی این طوری نیست
چرا این طوری نیست؟
برای اینکه اگر با وضعیتی که اینجا میریم جلو
یعنی با استیت ( که جلوتر میفهمیم چیه)
(البته روش های مختلفی وجود داره و این یکی از بهترین روش هاست.
 خود گوگل هم خیلی روی این روش تاکید داره و میگه با این روش برین جلو
 ولی مستندات کاملی نداره اصلا
  پس این آموزش رو خیلی جدی بگیرید
  چون اگر پیجینگی دارید که قراره دیتای اضافه ای بگیره
  صد در صد جلوتر به مشکل خواهید خورد )

زمانی که ما از استیت استفاده نکنیم و به صورت خیلی عادی و بیسیک بریم جلو چه اتفاقی می افته؟
اگه خیلی عادی ورودیا رو بفرستی چی میشه؟
زمانی که توی فرگمنت استفاده میکنی میبینی که ورودی رو نمیگیره
و بدون اون ورودی میخواد عملیات رو برات انجام بده

برای هندل کردن این موضوع از استیت خود ویومدل استفاده میکنیم
و دیگه خیالمون راحته که اطلاعات درست رو دریافت میکنیم

@HiltViewModel
class CategoriesViewModel @Inject constructor(private val repository: CategoriesRepository, state: SavedStateHandle) : ViewModel() {


برای این موضوع از یک لایو دیتا استفاده میکنیم که داخل استیت خود ویومدل هست
این لایو دیتا از ما دو تا ورودی میگیره
اولیش کویری هست
که البته منظور از این کوءری اون کوءری نیست که تو دیتابیس و این هاست
مثلا دسته بندی چی باشه و این ها

دو تا ورودی ما یکیش کارنت کوعری هست
یعنی چیزی که الان هست
و یه دونه هم حالت پیش فرض
چرا؟
چون به واسطه این حالت پیش فرض بهش میگه حتی اگه هیچ ورودی برای تو در نظر نگرفت
تو همه رو بده

دسترسی به این لایو دیتای خاص از طریق استیت خود ویومدل هست
و خب ما به جای اینیشیالایز کردن چیزایی که نیاز داریم داخل کلاس به کلاس تزریقشون میکنیم

ما این متغیر رو پرایویت تعریف میکنیم
چون فقط اون حالت پیش فرضمون رو میخوایم بهش بدیم
شاید بپرسید پس ورودی رو کجا ست میکنی؟
اون رو به یک شکل دیگه قراره ست کنیم
این فقط داره اون حالت پیش فرض  و حالت کنونی رو برامون برمیگردونه
که فقط میخوام توی این صفحه دسترسی داشته باشم
حالت پیش فرض که مشخصه. استرینگ خالی است
هر دوی این کوعری ها به صورت ثابت هستن
    private val currentData = state.getLiveData(CURRENT_QUERY, DEFAULT_QUERY)

 ***************** نکته خیلی مهم و جالب *********
 میتونی کانستنت ها رو بیاری توی همون فایل همیشگی کانستنت تعریف کنی
 ولی اگه کانستنتی داره که دوس داری فقط توی همون کلاس بهش دسترسی داشته باشی
 میتونی ببریش توی کامپنین آبجکت تعریفش کنی
 کاربردهای دیگه ای هم داره کامپنین آبجکت
 ولی یه کاربردش همین کانستنت تعریف کردن داخل یک کلاس هست
 *************************************************

 حالا روی اون لایودیتای استیت یک سوییچ مپ میزنیم
 این دیتایی که این بمون میده در واقع همون اطلاعاتیه که برامون برمیگردونه
 مثلا آیدی کتگوری
 از اینجا ریپازیتوری رو کال میکنیم و آیدی رو بهش میدیم
 تا اینجا تمومه
 ولی اگر بخوایم این api کش بشه
 خیلی راحت از حالت کشد این استفاده میکنیم
 و اسکوپ ویومدل رو بهش میدیم
 اینجوری سرویس کش میشه
 اگه چیز جدید داشته باشه میاره
 اگه نه از کش برات میاره
 ولی آپشنال هست و آپشن جالبیه

     val categoriesPhotos = currentData.switchMap { id ->
         // in faghat too code ghabli bood
         repository.categoryPhotos(id).cachedIn(viewModelScope)
     }

 حالا برای آپدیت کردن کوعری باید چیکار کنیم؟
 ورودی رو باید کجا بدیم بهش
 از طریق این متد ست میکنیم
 {
 اگه چندین وروردی داشتیم باید چندین لایو دیتا و چندین سوییچ مپ تعریف کنیم احتمالا
 }
     fun updateCategoryId(id: String) {
         currentData.value = id
     }

*************** نکته خیلی مهم درباره لایف سایکل****************
اگه من کدی دارم که میخوام یک بار اجرا شه مثلا کال کردن یک سرویس
یک راهش اینه که ببرم توی بلاک اینیت ویو مدل بنویسم
ولی اگه مثلا دیتایی داره که قراره از آرگز بگیرم چی
خب بازم میشه توی ویومدل هندلش کرد
ولی اگه بخوام توی خود فرگمنت باشه چی؟
اگه توی onViewCreated بنویسم با هر دفعه رفت و برگشت کال میشه
ولی توی onCreate فقط یک بار صدا زده میشه
لایف سایکل ها رو جدی بگیرید
***************************************************************